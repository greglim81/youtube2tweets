import { NextResponse } from 'next/server';
import OpenAI from 'openai';
import axios from 'axios';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface CaptionTrack {
  baseUrl: string;
  name?: {
    simpleText: string;
  };
  languageCode: string;
  kind?: string;
}

async function getCaptionsUrl(videoId: string): Promise<string | null> {
  try {
    console.log('Fetching video page for ID:', videoId);
    const response = await axios.get(`https://www.youtube.com/watch?v=${videoId}`, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
      }
    });
    const html = response.data;
    
    // Extract caption tracks from the page
    console.log('Searching for caption tracks in HTML');
    const captionTracksMatch = html.match(/"captionTracks":(\[.*?\])/);
    if (!captionTracksMatch) {
      // Try alternative pattern
      const alternativeMatch = html.match(/"captions":\s*{\s*"playerCaptionsTracklistRenderer":\s*{\s*"captionTracks":\s*(\[.*?\])/);
      if (!alternativeMatch) {
        console.log('No caption tracks found in HTML');
        return null;
      }
      console.log('Found caption tracks using alternative pattern');
      const captionTracks = JSON.parse(alternativeMatch[1]) as CaptionTrack[];
      return processCaptionTracks(captionTracks);
    }
    
    console.log('Found caption tracks, parsing JSON');
    const captionTracks = JSON.parse(captionTracksMatch[1]) as CaptionTrack[];
    return processCaptionTracks(captionTracks);
  } catch (error) {
    console.error('Error fetching captions URL:', error);
    return null;
  }
}

function processCaptionTracks(captionTracks: CaptionTrack[]): string | null {
  console.log('Available caption tracks:', JSON.stringify(captionTracks, null, 2));
  
  // First try to find manual English captions
  const englishTrack = captionTracks.find((track) => 
    track.languageCode === 'en' && 
    track.kind !== 'asr' &&
    track.name?.simpleText?.toLowerCase().includes('english')
  );
  
  if (englishTrack) {
    console.log('Found manual English captions:', englishTrack.baseUrl);
    return englishTrack.baseUrl;
  }
  
  // Then try auto-generated English captions
  console.log('No manual English track found, looking for auto-generated captions');
  const autoGeneratedTrack = captionTracks.find((track) => 
    track.kind === 'asr' && 
    track.languageCode === 'en'
  );
  
  if (autoGeneratedTrack) {
    console.log('Found auto-generated captions:', autoGeneratedTrack.baseUrl);
    return autoGeneratedTrack.baseUrl;
  }
  
  // Finally, try any English captions
  const anyEnglishTrack = captionTracks.find((track) => 
    track.languageCode === 'en' || 
    track.name?.simpleText?.toLowerCase().includes('english')
  );
  
  if (anyEnglishTrack) {
    console.log('Found any English captions:', anyEnglishTrack.baseUrl);
    return anyEnglishTrack.baseUrl;
  }
  
  console.log('No English captions found');
  return null;
}

async function fetchTranscriptWithRetry(videoId: string, maxRetries = 3): Promise<string> {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Attempt ${attempt} to fetch transcript`);
      const captionsUrl = await getCaptionsUrl(videoId);
      if (!captionsUrl) {
        throw new Error('No captions available for this video');
      }

      console.log('Fetching captions from URL:', captionsUrl);
      const response = await axios.get(captionsUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      });
      const xml = response.data;
      console.log('Received XML response:', xml.substring(0, 200) + '...');
      
      // Extract text from XML
      const textContent = xml
        .replace(/<[^>]+>/g, ' ') // Remove XML tags
        .replace(/\s+/g, ' ')     // Normalize whitespace
        .trim();
      
      if (!textContent) {
        throw new Error('No text content found in captions');
      }
      
      console.log('Extracted text content:', textContent.substring(0, 200) + '...');
      return textContent;
    } catch (error) {
      lastError = error;
      console.log(`Attempt ${attempt} failed:`, error);
      
      if (attempt < maxRetries) {
        // Wait for 1 second before retrying
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
  
  throw lastError;
}

export async function POST(request: Request) {
  try {
    const { url } = await request.json();

    if (!url) {
      return NextResponse.json(
        { message: 'YouTube URL is required' },
        { status: 400 }
      );
    }

    // Extract video ID from URL
    const videoId = extractVideoId(url);
    if (!videoId) {
      return NextResponse.json(
        { message: 'Invalid YouTube URL' },
        { status: 400 }
      );
    }

    // Fetch transcript with retry logic
    let rawTranscript;
    try {
      rawTranscript = await fetchTranscriptWithRetry(videoId);
    } catch (error) {
      console.error('Failed to fetch transcript after retries:', error);
      return NextResponse.json(
        { 
          message: 'Unable to fetch transcript. This video might not have captions available or they might be disabled.',
          error: error instanceof Error ? error.message : 'Unknown error'
        },
        { status: 400 }
      );
    }

    if (!rawTranscript.trim()) {
      return NextResponse.json(
        { message: 'No transcript content found for this video' },
        { status: 400 }
      );
    }

    // Use OpenAI to improve readability
    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content: "You are a helpful assistant that improves the readability of transcripts while preserving all the original content. Add proper punctuation, fix grammar, and organize the text into paragraphs where appropriate. Do not add or remove any information from the original transcript."
        },
        {
          role: "user",
          content: rawTranscript
        }
      ],
      temperature: 0.1,
    });

    const improvedTranscript = completion.choices[0].message.content;

    return NextResponse.json({ transcript: improvedTranscript });
  } catch (error) {
    console.error('Transcription error:', error);
    return NextResponse.json(
      { 
        message: 'Failed to process transcript',
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/)([^&\n?#]+)/,
    /youtube\.com\/embed\/([^&\n?#]+)/,
    /youtube\.com\/v\/([^&\n?#]+)/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }

  return null;
} 